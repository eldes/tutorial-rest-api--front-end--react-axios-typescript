# Tutorial: ConexÃ£o de um aplicativo React, em TypeScript, a um servidor REST API, usando Axios

![Foto decorativa](https://miro.medium.com/max/2000/1*RuWuZSZU_5CkenkEKBRBug.png)

Neste tutorial vocÃª vai aprender a criar um aplicativo web com React, em linguagem [TypeScript](https://www.TypeScriptlang.org/), e usando Axios para conectar a um servidor REST API.

Originalmente foi escrito para meus alunos das turmas de desenvolvimento web, como conteÃºdo introdutÃ³rio Ã  programaÃ§Ã£o front-end. Por esse motivo, partes do cÃ³digo e da lÃ³gica de programaÃ§Ã£o foram intencionalmente simplificadas, com finalidade didÃ¡tica.

As instruÃ§Ãµes apresentadas aqui independem do editor de cÃ³digo ou IDE utilizados, mas para elaborar e testar o cÃ³digo desse tutorial foi utilizado o [Visual Studio Code](https://code.visualstudio.com/).

Os comandos utilizados nesse tutorial sÃ£o baseados diretamente no [yarn](https://yarnpkg.com/), mas caso vocÃª prefira [npm](https://www.npmjs.com/) use:

- ***npm init*** em vez de ***yarn init***
- ***npm install*** *mÃ³dulo* em vez de ***yarn add*** *mÃ³dulo*
- ***npm run*** *script* em vez de ***yarn*** *script*
- ***npx*** *comando* em vez de ***yarn*** *comando*

### Requisitos

Para seguir esse tutorial vocÃª vai precisar dos seguintes softwares instalados no seu sistema:

- [Node.js](https://nodejs.org/)
- [yarn](https://yarnpkg.com/) (ou npm)
- [Git](https://git-scm.com/)

### Mapa de navegaÃ§Ã£o

O aplicativo web que serÃ¡ desenvolvido irÃ¡ implementar a interface para as 4 operaÃ§Ãµes bÃ¡sicas de CRUD (***C**reate*,  ***R**ead*, ***U**pdate*, ***D**elete*) sobre uma entidade genÃ©rica de dados chamada *Item*.

Cada *Item* possui dois campos obrigatÃ³rios, *nome* e *descriÃ§Ã£o*, e um campo opcional, *id*, que indica se o *Item* jÃ¡ foi cadastrado no sistema, ou seja se jÃ¡ foi gravado na base de dados do servidor.

Assim, a interface vai ter uma pÃ¡gina **Itens**, que irÃ¡ listar todos os *Itens* cadastrados no sistema, e uma outra pÃ¡gina **Item**, que irÃ¡ exibir os detalhes (*nome* e *descriÃ§Ã£o*) de um *Item* especÃ­fico.

A partir da pÃ¡gina **Itens** serÃ¡ possÃ­vel criar e cadastrar um novo *Item* no sistema.

E a partir da pÃ¡gina **Item** serÃ¡ possÃ­vel alterar os detalhes ou apagar um *Item* jÃ¡ cadastrado no sistema.

Essa estutura Ã© representada na figura a seguir:

![README-front-end-map](https://miro.medium.com/max/862/1*ILdywlbwPOwe8mvctJPYRQ.png)

*Figura 1 â€“Â Mapa de navegaÃ§Ã£o do aplicativo.*

### Servidor

O aplicativo irÃ¡ se conectar ao servidor e se comunicar via REST API com os seguintes *endpoints*:

- **GET /itens** â€“ retorna um JSON com um array contendo todos os *Itens* cadastrados no sistema.
- **POST /itens** â€“ recebe um JSON com os detalhes de um *Item* para ser cadastrado no sistema.
- **GET /itens/:id** â€“Â retorna um JSON com os detalhes de um *Item* especÃ­fico.
- **UPDATE /itens/:id** â€“Â recebe um JSON com os detalhes de um *Item* cadastrado no sistema para ser atualizado.
- **DELETE /itens/:id** â€“Â apaga um *Item* do sistema.

Para esse tutorial, iremos considerar **`http://localhost:4000/api/`** como a URL base desses *endpoints*, e a estrutura JSON, como no exemplo abaixo, para a entidade *Item*:

```json
{
	"id": 1,
	"nome": "Item 1",
	"descricao": "Descricao do Item 1."
}
```

Para testar o aplicativo React, a ser desenvolvido neste tutorial, vocÃª pode usar o servidor REST API elaborado a partir do [Tutorial: AplicaÃ§Ã£o REST API com Node, em TypeScript, usando Express e SQLite](https://github.com/eldes/tutorial-rest-api-nodejs-express-sqlite-TypeScript).

------

## 1. Projeto React base

O primeiro passo Ã© criar um projeto React base, com suporte a TypeScript. Ou seja, a partir do terminal de comandos execute:

```sh
yarn create react-app tutorial-rest-api-front-end --template typescript
```

> #### Explicando o comando
>
> Esse comando irÃ¡ criar uma pasta, chamada ***tutorial-rest-api-front-end***, contendo os arquivos iniciais do projeto React.
>
> Portanto, tenha o cuidado de executar esse comando a partir da pasta onde vocÃª gostaria que essa nova subpasta ***tutorial-rest-api-front-end*** seja criada.
>
> Depois de completada a execuÃ§Ã£o do comando, vocÃª pode abrir essa nova pasta, ***tutorial-rest-api-front-end***, no seu IDE, como o Visual Studio Code, e executar de lÃ¡ os demais comandos que veremos a seguir.
>
> Caso queira escolher um nome diferente de "app-react" para seu aplicativo, use apenas letras minÃºsculas separadas por hÃ­fen (podendo conter dÃ­gitos no meio).

Vamos testar? Para isso basta executar o script ***start***, a partir do terminal, na pasta do projeto:

```sh
yarn start
```

Uma pÃ¡gina deverÃ¡ ser aberta automaticamente no seu navegador padrÃ£o, exibindo uma animaÃ§Ã£o do sÃ­mbolo do React.

Pronto! Nesse ponto vocÃª tem uma versÃ£o de um projeto React base funcionando.

### Commit â€“Â *Initialize project using Create React App*

Juntamente com o projeto base, o ***create-react-app*** irÃ¡ criar tambÃ©m um repositÃ³rio Git local para o controle de versÃ£o, e um primeiro *commit* serÃ¡ feito automaticamente.

Se vocÃª usa o padrÃ£o *GitFlow*, Ã© um bom momento para iniciÃ¡-lo no seu repositÃ³rio.

------

## 2. Roteamento de pÃ¡ginas

Para organizar nosso projeto, vamos criar uma pasta chamada ***pages*** dentro da pasta ***src***.

Essa pasta irÃ¡ conter todas as pÃ¡ginas do nosso aplicativo web.

### Modelo da pÃ¡gina Itens

A primeira pÃ¡gina que iremos criar para nosso aplicativo serÃ¡ a ***Itens*** (vide *Figura 1*), que irÃ¡ listar todos os *Itens* cadastrados no sistema.

Portanto, vamos criar um arquivo chamado ***itens.tsx***, dentro da pasta ***pages***, com o seguinte cÃ³digo:

```tsx
import { FunctionComponent } from 'react'

const ItensPage: FunctionComponent = () => {
	return (
		<>
			<h1>Itens</h1>
		</>
	)
}

export default ItensPage
```

> #### Explicando o cÃ³digo
>
> Cada pÃ¡gina do nosso aplicativo serÃ¡ implementada como um componente do React e terÃ¡ um arquivo (script) prÃ³prio, salvo na pasta ***pages***. A funÃ§Ã£o desse componente Ã© basicamente definir o HTML principal da pÃ¡gina.
>
> E o modo mais simples de definir um componente Ã© escrevendo uma funÃ§Ã£o TypeScript, que retorna seu cÃ³digo HTML, como por exemplo:
>
> ```tsx
> () => {
> 	return (
> 		<p>CÃ³digo HTML do componente</p>
> 	)
> }
> ```
>
> Assim, nossa pÃ¡gina que lista os itens do sistema, **`ItensPage`**, serÃ¡ uma constante do tipo **`FunctionComponent`**que recebe uma funÃ§Ã£o retornando o HTML da pÃ¡gina:
>
> ```tsx
> const ItensPage: FunctionComponent = () => {
> 	return (
> 		<>
> 				<h1>Itens</h1>
> 		</>
> 	)
> }
> ```
>

### Rotas

Para definir qual pÃ¡gina serÃ¡ exibida por meio para uma determinada rota especificada na URL, iremos usar o mÃ³dulo *react-router-dom*.

Para instalar esse mÃ³dulo, executamos no terminal:

```sh
yarn add react-router-dom
yarn add @types/react-router-dom
```

### Script App

O prÃ³ximo passo Ã© ajustar o arquivo ***/src/App.tsx***, substituindo o seu conteÃºdo original pelo seguinte cÃ³digo:

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import ItensPage from './pages/itens'

const App = () => {
	return(
		<BrowserRouter>
			<Routes>
				<Route path="/itens" element={<ItensPage/>} />
			</Routes>
		</BrowserRouter>
	)
}

export default App
```

Para testar, abra a URL http://localhost:3000/itens no seu navegador e assim a pÃ¡gina ***Itens*** deverÃ¡ ser exibida.

> #### Explicando o cÃ³digo
>
> Nosso aplicativo segue o padrÃ£o de *SPA*, ou *Single Page Application* (aplicaÃ§Ã£o de pÃ¡gina Ãºnica), isto Ã© aplicativos web (web app) compostos de apenas um Ãºnico documento HTML e que proporcionam uma experiÃªncia similar a de um aplicativo mobile ou desktop, sem os recarregamentos comuns dos sites.
>
> O **`BrowserRouter`**, em conjunto com o **`Routes`**, serve para definir qual componente *page* deverÃ¡ ser exibido para uma determinada rota.
>
> No nosso caso, serÃ¡ exibido o componente **`ItensPages`** , ou seja a pÃ¡gina ***Itens***, para a rota ***/itens***.
>

### Commit â€“Â *[+] roteamento de pÃ¡ginas*

Nesse ponto do tutorial, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um *commit*. Assim execute os seguintes comandos em um terminal:

```sh
git add .
git commit -m "[+] roteamento de pÃ¡ginas"
```

> ğŸ’¡ Ã‰ interessante trabalhar com duas instÃ¢ncias de terminal de comando: uma para executar os scripts do projeto, como o **`yarn dev`**, por exemplo, e outra para executar comandos auxiliares, como as operaÃ§Ãµes do Git.

------

## 3. ConexÃ£o ao servidor

### Estados

Num primeiro momento, a pÃ¡gina ***Itens*** irÃ¡ ter trÃªs estados:

1. **Lendo:** exibe uma mensagem de progresso enquanto lÃª a lista de *Itens* a partir do servidor.
2. **Erro Ler:** exibe uma mensagem de erro, caso haja falha ao ler a lista.
3. **Lido:** exibe a lista que foi lida do servidor.

A figura seguinte ilustra o fluxo entre esses estados:

![README-front-end-wireframe-itens-fase-1](https://miro.medium.com/max/1400/1*URr7sr8DxfeQHHPnxcyRgw.png)

*Figura 2 â€“ Wireframe e fluxo inicial entre os estados da pÃ¡gina Itens.*

### Elementos da interface

De acordo com esse wireframe (*Figura 2*), vamos definir o HTML completo da pÃ¡gina, contendo todos os elementos que podem ser exibidos em cada um daqueles trÃªs estados.

Assim, o cÃ³digo do componente **`ItensPage`**, no script ***/src/pages/itens.tsx***, fica como o seguinte:

```tsx
const ItensPage: FunctionComponent = () => {
	return (
		<>
			<p>Carregando...</p>
    
			<p>ERRO ao tentar carregar.</p>
    
			<h1>Itens</h1>
			<ul>
				<li>Item 1</li>
				<li>Item 2</li>
				<li>Item 3</li>
			</ul>
		</>
	)
}
```

### Interface de acordo com o estado da pÃ¡gina

E para controlar quais elementos devem aparecer em cada estado da pÃ¡gina, vamos criar, logo antes do **`return`** da funÃ§Ã£o do componente, um **`enum`** com valores referentes a cada um dos possÃ­veis trÃªs estados:

```tsx
enum Estado {
	Lendo,
	ErroLer,
	Lido,
}
```

E, logo abaixo do**`enum`**, vamos criar um *state*, do tipo **`Estado`**, para definir em qual estado a pÃ¡gina se encontra, iniciando com **`Lendo`**:

```tsx
const [estado, setEstado] = useState(Estado.Lendo)
```

NÃ£o esquecer de importar a funÃ§Ã£o **`useState`**, no inÃ­cio desse arquivo:

```jsx
import { FunctionComponent, useState } from 'react'
```

A mensagem de progresso, "Carregando...", deverÃ¡ ser exibida durante leitura da lista de *Itens* vinda do servidor, ou seja, quando o *state* **`estado`** for igual a **`Estado.Lendo`**. Assim, a linha contendo o prÃ¡grafo (elemento **`<p>`**) da mensagem de progresso,  serÃ¡ substituÃ­da pelo cÃ³digo:

```tsx
{
	(estado === Estado.Lendo) && <p>Carregando...</p>
}
```

> #### Explicando o cÃ³digo:
>
> Nesse contexto, essa construÃ§Ã£o de cÃ³digo, usando o operador **`&&`**, tem a funÃ§Ã£o de um comando de decisÃ£o, ou seja, significa o mesmo que: *SE **`estado`** tiver valor igual a **`Estado.Lendo`**, ENTÃƒO serÃ¡ retornado um elemento **`p`**, com a mensagem "Carregando..."*.

Do mesmo modo, para o parÃ¡grafo com a mensagem de erro, quando houver falha ao se tentar ler a lista de *Itens*:

```tsx
{
	(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
}
```

Por fim, o cabeÃ§alho e a lista de *Itens* serÃ¡ exibida apenas no estado **`Lido`**:

```tsx
{
	(estado === Estado.Lido) &&
	<>
		<h1>Itens</h1>
		<ul>
        <li>Item 1</li>
        <li>Item 2</li>
        <li>Item 3</li>
     </ul>
	</>
}
```

ğŸ“„ Nesse ponto, o cÃ³digo completo do script ***/src/pages/itens.tsx*** fica entÃ£o assim:

```tsx
import { FunctionComponent, useState } from 'react'

const ItensPage: FunctionComponent = () => {

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}

			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Lido) &&
				<>
					<h1>Itens</h1>
					<ul>
						<li>Item 1</li>
						<li>Item 2</li>
						<li>Item 3</li>
					</ul>
				</>
			}
		</>
	)
}

export default ItensPage
```

 Se vocÃª testar seu aplicativo nesse momento, em http://localhost:3000/itens, deverÃ¡ ser exibida a tela com a mensagem "Carregando...".

### MÃ³dulo Axios

Por enquanto, a pÃ¡gina ***Itens*** estÃ¡ exibindo um conteÃºdo estÃ¡tico, definido em *hard-coding*. Ou seja, para acrescentar um novo *Item*, ou modificar ou apagar um *Item* existente, Ã© necessÃ¡rio alterar diretamente o cÃ³digo TypeScript da **`ItensPage`**, em ***/src/pages/itens.tsx***.

Mas, no final, o que pretendemos Ã© que o conteÃºdo dessa pÃ¡gina seja dinÃ¢mico, exibindo a lista de *Itens* armazenada na base de dados do *back-end*. Assim nosso aplicativo deverÃ¡ se conectar ao servidor e ler a lista de *Itens* via REST API.

Para efetuar essa conexÃ£o iremos utilizar o mÃ³dulo *Axios*. Para instalar esse mÃ³dulo no nosso projeto, executaremos no terminal:

```sh
yarn add axios
yarn add @types/axios
```

### Modelo

Ainda para organizar os arquivos do projeto, iremos criar tambÃ©m uma pasta ***models***, dentro da pasta ***src***. Essa pasta deverÃ¡ conter os modelos de entidades do nosso aplicativo.

Dentro dessa pasta vamos criar um arquivo ***item.ts*** com o seguinte cÃ³digo, refletindo a estrutura de dados da entidade *Item* do nosso *back-end*:

```tsx
type Item = {
	id?: number
	nome: string
	descricao: string
}

export default Item
```

> #### Explicando o cÃ³digo:
>
> O ponto de interrogaÃ§Ã£o, ao lado do campo **`id`**, significa que esse campo Ã© opcional.
>
> Isso porque, quando um *Item* for criado no *front-end*, esse campo sÃ³ vai ter um valor depois que ele for gravado na base de dados pelo *back-end*.

### ServiÃ§o

Vamos criar tambÃ©m uma pasta ***services***, dentro da pasta ***src***, que irÃ¡ conter os scripts da camada de serviÃ§o do aplicativo.

Essa camada Ã© que vai ter a responsabilidade de fazer a conexÃ£o com o servidor, efetuando operaÃ§Ãµes sobre as entidades do sistema, por meio dos *endpoints* da REST API.

ğŸ“„ Para a entidade *Item* vamos entÃ£o criar um arquivo ***itens.ts***, dentro dessa pasta, com o seguinte cÃ³digo:

```js
import axios from 'axios'
import Item from '../models/item'

const itensService = {

	lerTodos: (sucesso: (itens: Item[]) => void, falha: () => void) => {
		axios.get<Item[]>('http://localhost:4000/api/itens')
		.then(res => sucesso(res.data))
		.catch(() => falha())
	},

}

export default itensService
```

> #### Explicando o cÃ³digo:
>
> A constante **`itensService`** irÃ¡ reunir todos os mÃ©todos que refletem e executam as chamadas da REST API para a entidade *Item*.
>
> Esse primeiro mÃ©todo, **`lerTodos`**, Ã© usado para a chamada que consegue a lista de todos os *Itens* cadastrados no sistema, e possui dois parÃ¢metros que devem ser especificados ao ser usado: **`sucesso`** e **`falha`**.
>
> O primeiro parÃ¢metro, **`sucesso`**, Ã© uma funÃ§Ã£o que serÃ¡ executada quando a chamada ao *endpoint* for completada com sucesso (**`successo: (itens: Item[]) => void`**). Essa funÃ§Ã£o deve aceitar um parÃ¢metro do tipo array de *Itens* (**`itens: Item[]`**) e nÃ£o retornar nada (**`=> void`**).
>
> O segundo parÃ¢metro, **`falha`**, Ã© uma funÃ§Ã£o que serÃ¡ executada quando a chamada ao *endpoint* falhar (**`falha: () => void`**). Essa funÃ§Ã£o nÃ£o tem nenhum parÃ¢metro (**`()`**) e nÃ£o retorna nada (**`=> void`**).
>
> Ao ser chamado, o mÃ©todo **`lerTodos`** irÃ¡ fazer entÃ£o a conexÃ£o com o *endpoint* ***/itens*** do servidor(**`'http://localhost:4000/api/itens'`**), via mÃ©todo *GET* (**`axios.get`**), para conseguir, como resposta, um array de *Itens* (**`<Item[]>`**):
>
> ```js
> axios.get<Item[]>('http://localhost:4000/api/itens')
> ```
>
> Em caso de sucesso, apÃ³s terminada a chamada, Ã© executado o callback definido em **`then`**. No nosso caso, usamos o parÃ¢metro do objeto com a resposta do servidor (**`res`**) para entÃ£o chamar a funÃ§Ã£o **`sucesso`** (**`res => sucesso(res.data)`**). O corpo da resposta da chamada (**`res.data`**) Ã© o array de *Itens* que serÃ¡ passado para essa funÃ§Ã£o.
>
> Em caso de falha, Ã© executado o callback definido em **`catch`**. No nosso caso, simplesmente chamamos a funÃ§Ã£o **`falha`** que foi especificada (**`() => falha()`**).
>

### PÃ¡gina

Agora que jÃ¡ temos o mÃ©todo para conectar ao servidor e conseguir a lista de *Itens* do sistema, vamos entÃ£o ajustar o cÃ³digo de **`ItensPage`**, no arquivo ***/src/pages/itens.tsx***.

Primeiro vamos criar um novo *state*, **`itens`**, logo abaixo  do *state* **`estado`**,  no cÃ³digo do componente **`ItensPage`**:

```jsx
const [itens, setItens] = useState<Item[]>([])
```

> #### Explicando o cÃ³digo:
>
> O *state* **`itens`** Ã© do tipo array de **`Item`** (**`<Item[]>`**) e tem um array vazio (**`([])`**) como valor inicial. Esse *state* irÃ¡ conter a lista de *Itens* lida do servidor.
>

NÃ£o esquecer de importar o *type* **`Item`**, no inÃ­cio do arquivo:

```jsx
import Item from '../models/item'
```

Em seguida, vamos chamar o mÃ©todo **`lerTodos`**, de **`itensService`**, para entÃ£o alterar os valores dos *states* **`itens`** e **`estado`**.

Para isso adicionamos o seguinte trecho de cÃ³digo, logo apÃ³s as definiÃ§Ãµes dos *states*:

```tsx
useEffect(() => {
	setEstado(Estado.Lendo)
	itensService.lerTodos(
		itens => {
			setItens(itens)
			setEstado(Estado.Lido)
		},
		() => setEstado(Estado.ErroLer)
	)
}, [Estado.ErroLer, Estado.Lendo, Estado.Lido])
```

> #### Explicando o cÃ³digo:
>
> Qualquer cÃ³digo que possa modificar o valor de algum *state* usado pelo componente deve estar dentro da funÃ§Ã£o **`useEffect`**, para que seja executado somente apÃ³s a renderizaÃ§Ã£o estar disponÃ­vel na tela.
>
> Como a funÃ§Ã£o **`lerTodos`** pode modificar os valores dos *states* **`itens`** e **`error`**, ela Ã© entÃ£o chamada dentro do **`useEffect`**.
>
> O *array* com **`Estado.ErroLer`**, **`Estado.Lendo`** e **`Estado.Lido`**, passado como segundo parÃ¢metro do **`useEffect`**, significa que a execuÃ§Ã£o dessa funÃ§Ã£o depende desses valores do *enum* **`Estado`**.

NÃ£o esquecer de importar a funÃ§Ã£o **`useEffect`** e o **`itensService`**no inÃ­cio do arquivo:

```jsx
import { FunctionComponent, useEffect, useState } from 'react'
import itensService from '../services/itens'
```

Em seguida usaremos o *state* **`itens`** para exibir a lista de *Itens* dinamicamente, substituindo o cÃ³digo da lista de *Itens* (**`<ul>`**) por:

```tsx
<ul>
{
	itens.map(item => <li key={item.id}>{item.nome}</li>)
}
</ul>
```

> #### Explicando o cÃ³digo:
>
> Sempre que o valor de um *state* muda, o componente onde ele Ã© usado Ã© recarregado, e renderizado novamente, de forma automÃ¡tica.
>
> Assim, quando o *state* **`itens`** muda seu valor, o componente **`ItensPage`** Ã© recarregado, listando o array de *Itens* desse *state*.
>
> Para criar o cÃ³digo HTML da  lista Ã© utilizada a funÃ§Ã£o **`map`**, que percorre todos os elementos do array **`itens`** e retorna um **`<li>`** para cada um.
>
> Quando se usa a funÃ§Ã£o **`map`** para criar uma lista de elementos, devemos usar o atributo especial **`key`** com um valor identifique unicamente cada elemento listado. No nosso caso, usamos a propriedade **`id`** do *Item* (**`key={item.key}`**).

ğŸ“„ Nesse ponto, o cÃ³digo integral de ***/src/pages/itens.tsx*** fica assim:

```tsx
import { FunctionComponent, useEffect, useState } from 'react'
import Item from '../models/item'
import itensService from '../services/itens'

const ItensPage: FunctionComponent = () => {

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [itens, setItens] = useState<Item[]>([])

	useEffect(() => {
		setEstado(Estado.Lendo)
		itensService.lerTodos(
			itens => {
				setItens(itens)
				setEstado(Estado.Lido)
			},
			() => setEstado(Estado.ErroLer)
		)
	}, [Estado.ErroLer, Estado.Lendo, Estado.Lido])

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}

			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Lido) &&
				<>
					<h1>Itens</h1>
					<ul>
					{
						itens.map(item => <li key={item.id}>{item.nome}</li>)
					}
					</ul>
				</>
			}
		</>
	)
}

export default ItensPage
```

Para testar, basta acessar a URL http://localhost:3000/itens no navegador.

Lembrando de iniciar o seu servidor *back-end* para que a pÃ¡gina consiga acessar o *endpoint* ***GET /api/itens***.

### Commit â€“ *[+] conexÃ£o ao servidor*

Nesse ponto do tutorial, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um novo *commit*:

```sh
git add .
git commit -m "[+] conexao ao servidor"
```

------

## 4. Detalhes do Item

Como prÃ³ximo passo, vamos criar uma pÃ¡gina para exibir os detalhes de um *Item* especÃ­fico cadastrado no sistema.

Para especificar de qual *Item* a pÃ¡gina deve mostrar os detalhes, iremos passar o *id* na prÃ³pria URL. Ou seja, para exibir os detalhes do *Item* com *id* 1, deverÃ¡ ser chamada a rota ***/itens/1***; para o *Item* com *id* 2, deverÃ¡ ser chamada a rota ***/itens/2***; e assim por diante.

Desse modo o *id* se torna um parÃ¢metro da rota dessa pÃ¡gina, que Ã© entÃ£o representada como ***/itens/:id***. 

### Estrutura bÃ¡sica do componente

Para iniciar a implementaÃ§Ã£o dessa pÃ¡gina, vamos criar um novo arquivo, ***item.tsx***, dentro da pasta ***/src/pages***, com a estrutura bÃ¡sica de componente:

```tsx
import { FunctionComponent } from 'react'

const ItemPage: FunctionComponent = () => {
	return (
		<>PÃ¡gina do Item X</>
	)
}

export default ItemPage
```

### Rota

Para que essa pÃ¡gina possa ser acessada, devemos adicionar uma rota para ela, no script ***/src/App.tsx***, logo abaixo do rota para a pÃ¡gina ***Itens***.

```tsx
<Route path="/itens/:id" element={<ItemPage/>} />
```

NÃ£o esquecer de importar o componente **`ItemPage`** no inÃ­cio do arquivo:

```tsx
import ItemPage from './pages/item'
```

ğŸ“„ O cÃ³digo completo desse script fica entÃ£o assim:

```tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import ItemPage from './pages/item'
import ItensPage from './pages/itens'

const App = () => {
	return(
		<BrowserRouter>
			<Routes>
				<Route path="/itens" element={<ItensPage/>} />
				<Route path="/itens/:id" element={<ItemPage/>} />
			</Routes>
		</BrowserRouter>
	)
}

export default App
```

Para testar, abra a URL http://localhost:3000/itens/1.

### Id do Item

Mas, em vez de ***X***, queremos que seja exibido o *id* que foi passado na rota. Ou seja, a pÃ¡gina deverÃ¡ exibir "PÃ¡gina do Item 1", caso a URL seja http://localhost:3000/itens/1, "PÃ¡gina do Item 2", caso a URL seja http://localhost:3000/itens/2, e assim por diante.

Desse modo, vamos ajustar o cÃ³digo da pÃ¡gina para obter, por meio do *hook* **`useParams()`**, o valor do parÃ¢metro *id* passado na URL. Para isso vamos adicionar a seguinte linha, logo antes do **`return`**:

```tsx
const { id } = useParams()
```

E trocar **`X`** por **`{id}`** no cÃ³digo HTML do componente da pÃ¡gina:

```tsx
<>PÃ¡gina do Item {id}</>
```

Lembrando de importar a funÃ§Ã£o **`useParams`** no inÃ­cio do arquivo:

```tsx
import { useParams } from 'react-router-dom'
```

ğŸ“„ Nesse ponto, o arquivo completo de ***/src/pages/item.tsx*** fica entÃ£o assim:

```jsx
import { FunctionComponent } from 'react'
import { useParams } from 'react-router-dom'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	return (
		<>PÃ¡gina do Item {id}</>
	)
}

export default ItemPage
```

Ao testar novamente, agora a pÃ¡gina deverÃ¡ exibir o *id* que foi passado como parÃ¢metro na URL.

### Link na pÃ¡gina Itens

Para completar essa etapa, vamos voltar Ã  pÃ¡gina ***Itens*** (***/src/pages/itens.tsx***) e adicionar um link para a pÃ¡gina ***Item***.

Assim, vamos substituir o cÃ³digo do item de lista (**`<li>`**) por:

```tsx
<li key={item.id}><Link to={`/itens/${item.id}`}>{item.nome}</Link></li>
```

NÃ£o esquecendo de importar o componente **`Link`** no inÃ­cio do arquivo:

```tsx
import { Link } from 'react-router-dom'
```

O cÃ³digo completo da pÃ¡gina ***Itens*** fica entÃ£o assim:

```tsx
import { FunctionComponent, useEffect, useState } from 'react'
import { Link } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItensPage: FunctionComponent = () => {

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [itens, setItens] = useState<Item[]>([])

	useEffect(() => {
		setEstado(Estado.Lendo)
		itensService.lerTodos(
			itens => {
				setItens(itens)
				setEstado(Estado.Lido)
			},
			() => setEstado(Estado.ErroLer)
		)
	}, [Estado.ErroLer, Estado.Lendo, Estado.Lido])

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}

			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Lido) &&
				<>
					<h1>Itens</h1>
					<ul>
					{
						itens.map(item => <li key={item.id}><Link to={`/itens/${item.id}`}>{item.nome}</Link></li>)
					}
					</ul>
				</>
			}
		</>
	)
}

export default ItensPage
```

Agora conseguiremos navegar da pÃ¡gina ***Itens*** para a pÃ¡gina ***Item*** a partir de um clique no nome do respectivo *Item*.

### Estados da pÃ¡gina

Num primeiro momento, de acordo com seu funcionamento, a pÃ¡gina ***Item*** irÃ¡ ter trÃªs estados:

1. **Lendo:** exibe uma mensagem de progresso enquanto lÃª os dados do *Item* a partir do servidor.
2. **Erro Ler:** exibe uma menagem de erro caso haja falha ao ler os dados.
3. **Lido:** exibe os dados do *Item*, lidos do servidor.

A figura seguinte ilustra o fluxo entre esses estados:

![README-front-end-wireframe-fase-1](https://miro.medium.com/max/1400/1*od-vVerUSSYXTvJLDM0jwQ.png)

*Figura 3 â€“ Wireframe e fluxo inicial entre os estados da pÃ¡gina de detalhes do Item.*

### Elementos da interface

De acordo com o wireframe definido na *Figura 3*, vamos definir o HTML completo da pÃ¡gina, contendo todos os elementos que podem ser exibidos em cada um daqueles trÃªs estados.

Assim, substituÃ­mos o cÃ³digo do **`return`** do componente **`ItemPage`** por:

```tsx
return (
	<>
		<p>Carregando...</p>

		<p>ERRO ao tentar carregar.</p>
			
		<h1>Nome do item {id}</h1>
		<p>DescriÃ§Ã£o do item {id}</p>
		<div>
			<button>Editar</button>
		</div>
	</>
)
```

### Interface de acordo com o estado da pÃ¡gina

E para controlar quais elementos devem aparecer em cada estado da pÃ¡gina, vamos criar, logo antes do **`return`**, um *enum* com valores referentes a cada um dos possÃ­veis trÃªs estados:

```tsx
enum Estado {
	Lendo,
	ErroLer,
	Lido,
}
```

E, assim como na pÃ¡gina ***Itens***, logo abaixo do**`enum`**, vamos criar um *state*, do tipo **`Estado`**, para definir em qual estado a pÃ¡gina se encontra, iniciando com **`Lendo`**:

```tsx
const [estado, setEstado] = useState(Estado.Lendo)
```

NÃ£o esquecendo de importar o a funÃ§Ã£o **`useState`** no inÃ­cio do arquivo:

```tsx
import { FunctionComponent, useState } from 'react'
```

A mensagem de progresso, "Carregando...", deverÃ¡ ser exibida durante leitura dos dados do *Item*, vindos do servidor. Ou seja, serÃ¡ exibida quando o *state* **`estado`** for igual a **`Estado.Lendo`**. Assim substituÃ­mos o parÃ¡gafo (**`<p>`**) da mensagem por:

```tsx
{
	(estado === Estado.Lendo) && <p>Carregando...</p>
}
```

Do mesmo modo, para a mensagem de erro ao se tentar ler os dados do *Item*:

```tsx
{
	(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
}
```

O nome e a descriÃ§Ã£o do *Item*, juntamente com o botÃ£o ***Editar***, serÃ£o exibidos no estado ***Lido***. Assim alteramos essas respectivas linhas para:

```tsx
{
	(estado === Estado.Lido) &&
	<>
		<h1>Nome do item {id}</h1>
		<p>DescriÃ§Ã£o do item {id}</p>
		<div>
			<button>Editar</button>
		</div>
	</>
}
```

ğŸ“„ Nesse ponto, o cÃ³digo completo do script ***/src/pages/item.tsx*** fica entÃ£o assim:

```tsx
import { FunctionComponent, useState } from 'react'
import { useParams } from 'react-router-dom'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}
				
			{
				(estado === Estado.Lido) &&
				<>
					<h1>Nome do item {id}</h1>
					<p>DescriÃ§Ã£o do item {id}</p>
					<div>
						<button>Editar</button>
					</div>
				</>
			}
		</>
	)
}

export default ItemPage
```

### ServiÃ§o

O prÃ³ximo passo Ã© adicionar a operaÃ§Ã£o de leitura dos dados de um *Item* especÃ­fico a partir do servidor.

Assim, vamos ajustar o cÃ³digo do **`itensService`** para efetuar essa a operaÃ§Ã£o adicionando uma nova funÃ§Ã£o, **`ler`**, logo abaixo da **`lerTodos`**, no arquivo ***/src/services/itens.ts***:

```tsx
ler: (id: number, sucesso: (item: Item) => void, falha: () => void) => {
	axios.get<Item>(`http://localhost:4000/api/itens/${id}`)
	.then(res => (res.status === 200) ? sucesso(res.data) : falha())
	.catch(error => falha())
},
```

ğŸ“„ O cÃ³digo completo desse script fica entÃ£o:

```tsx
import axios from 'axios'
import Item from '../models/item'

const itensService = {

	lerTodos: (sucesso: (itens: Item[]) => void, falha: () => void) => {
		axios.get<Item[]>('http://localhost:4000/api/itens')
		.then(res => sucesso(res.data))
		.catch(() => falha())
	},

	ler: (id: number, sucesso: (item: Item) => void, falha: () => void) => {
		axios.get<Item>(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 200) ? sucesso(res.data) : falha())
		.catch(error => falha())
	},

}

export default itensService
```

### ExibiÃ§Ã£o dos dados lidos

Na sequÃªncia, vamos voltar para ajustar o script ***/src/pages/item.tsx***, da pÃ¡gina ***Itens***, de modo a chamar a operaÃ§Ã£o **`ler()`** para preencher a pÃ¡gina com os dados vindos do servidor.

Para isso vamos criar um *state* **`item`**, logo abaixo do *state* **`estado`**, para armazenar esses dados e, posteriormente, ser usado para gerar o HTML final da pÃ¡gina:

```tsx
const [item, setItem] = useState<Item>()
```

NÃ£o esquecendo de importar o *type* **`Item`**:

```tsx
import Item from '../models/item'
```

Assim como no script da pÃ¡gina que lista todo os *Itens* do sistema, ***/src/pages/itens.tsx***, tambÃ©m vamos colocar o cÃ³digo efetuando a operaÃ§Ã£o **`ler()`** dentro de um **`useEffect()`**. EntÃ£o, logo em seguida do state **`item`**, vamos adicionaro cÃ³digo:

```tsx
useEffect(() => {
	if (id) {
		itensService.ler(
			+id,
			item => {
				setItem(item)
				setEstado(Estado.Lido)
			},
			() => setEstado(Estado.ErroLer)
		)
	}
}, [id, Estado.Lido, Estado.ErroLer])
```

> #### Explicando do cÃ³digo:
>
> Caso a operaÃ§Ã£o tenha sucesso, os dados serÃ£o gravados no state **`item`** (**`setItem(item)`**) e o estado da pÃ¡gina serÃ¡ definido como ***Lido*** (**`setEstado(Estado.Lido)`**). Caso contrÃ¡rio o estado da pÃ¡gina serÃ¡ definido como ***Erro Ler***.

NÃ£o esquecendo de importar a funÃ§Ã£o  **`useEffect`** e o componente **`itensService`**:

```tsx
import { FunctionComponent, useEffect, useState } from 'react'
import itensService from '../services/itens'
```

Para a pÃ¡gina exibir os dados lidos, vamos entÃ£o ajustar o cÃ³digo para mostrar o nome e a descriÃ§Ã£o do *Item*:

```tsx
{
	(estado === Estado.Lido) &&
	<>
		<h1>{item?.nome}</h1>
		<p>{item?.descricao}</p>
		<div>
			<button>Editar</button>
		</div>
	</>
}
```

ğŸ“„ O cÃ³digo completo do script da pÃ¡gina ***Item*** fica entÃ£o:

```tsx
import { FunctionComponent, useEffect, useState } from 'react'
import { useParams } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [item, setItem] = useState<Item>()

	useEffect(() => {
		if (id) {
			itensService.ler(
				+id,
				item => {
					setItem(item)
					setEstado(Estado.Lido)
				},
				() => setEstado(Estado.ErroLer)
			)
		}
	}, [id, Estado.Lido, Estado.ErroLer])

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}
				
			{
				(estado === Estado.Lido) &&
				<>
					<h1>{item?.nome}</h1>
					<p>{item?.descricao}</p>
					<div>
						<button>Editar</button>
					</div>
				</>
			}
		</>
	)
}

export default ItemPage
```

### Commit â€“ *[+] pÃ¡gina item*

Para esse tutorial, nesse ponto, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um *commit*:

```sh
git add .
git commit -m "[+] pÃ¡gina item"
```

------

## 5. Editar o Item

A partir dessa mesma pÃ¡gina, ***Item***, o usuÃ¡rio vai poder alterar os dados (*nome* e *descriÃ§Ã£o*) do *Item* (vide *Figura 1*).

### Estados da pÃ¡gina

Assim, o comportamento dessa pÃ¡gina vai ter, agora, mais 4 estados:

- **Editando:** exibe campos de ediÃ§Ã£o permitindo ao usuÃ¡rio alterar os dados do *Item*.
- **Salvando:** exibe uma mensagem de progresso enquanto salva os novos dados do *Item* no servidor.
- **Erro Salvar:** exibe uma mensagem de erro caso haja falha ao salvar os dados.
- **Salvo:** exibe uma mensagem de sucesso em relaÃ§Ã£o ao salvamento dos dados, e permitindo uma nova ediÃ§Ã£o.

Ou seja, 7 estados no total, como a figura seguinte ilustra:

![README-front-end-wireframe-fase-2](https://miro.medium.com/max/1400/1*QJvh6edWSSfIVao0R9qDJA.png)

*Figura 4 â€“Â Wireframe e fluxo entre os estados da pÃ¡gina de detalhes do Item.*

### Elementos da interface

Como prÃ³ximo passo, vamos completar o HTML da pÃ¡gina com todos os demais elementos que podem ser exibidos em cada um desses novos 4 estados.

Ou seja, logo abaixo do bloco que mostra os dados do *Item*, vamos acrescentar o formulÃ¡rio para o usuÃ¡rio editar esses dados:

```tsx
<form>
	<div>
		<label>
			Nome:
			<input />
		</label>
	</div>
	<div>
		<label>
			DescriÃ§Ã£o:
			<textarea></textarea>
		</label>
	</div>
	<div>
		<button>Salvar</button>
		<button>Cancelar</button>
	</div>
</form>
```

E, logo abaixo da mensagem de falha ao tentar carregar, vamos acrescentar as mensagens, de progresso, de sucesso e de falha, ao se tentar salvar:

```tsx
<p>Salvando...</p>

<p>SUCESSO em salvar!</p>

<p>ERRO ao tentar salvar.</p>
```

### Interface de acordo com o estado da pÃ¡gina

E para controlar quais elementos devem aparecer em cada estado da pÃ¡gina, vamos ajustar o *enum* **`Estado`**, acrescentando os novos 4 estados, e ficando assim no final:

```tsx
enum Estado {
	Lendo,
	ErroLer,
	Lido,
	Editando,
	Salvando,
	ErroSalvar,
	Salvo,
}
```

O nome e a descriÃ§Ã£o do *Item*, juntamente com o botÃ£o ***Editar***, serÃ£o exibidos tanto no estado ***Lido*** quanto no estado ***Salvo*** (vide Figura 4). Portanto vamos substituir esse bloco de cÃ³digo por:

```tsx
{
	((estado === Estado.Lido) || (estado === Estado.Salvo)) &&
	<div>
		<h1>{item?.nome}</h1>
		<p>{item?.descricao}</p>
		<div>
			<button>Editar</button>
		</div>
	</div>
}
```

O formulÃ¡rio de ediÃ§Ã£o serÃ¡ exibido tanto no estado ***Editando*** quanto no estado ***Erro Salvar***:

```tsx
{
	((estado === Estado.Editando) || (estado === Estado.ErroSalvar)) &&
	<form>
		<div>
			<label>
				Nome:
				<input />
			</label>
		</div>
		<div>
			<label>
				DescriÃ§Ã£o:
				<textarea></textarea>
			</label>
		</div>
		<div>
			<button>Salvar</button>
			<button>Cancelar</button>
		</div>
	</form>
}
```

A indicaÃ§Ã£o de progresso ao se tentar salvar as alteraÃ§Ãµes serÃ¡ exibida no estado ***Salvando***:

```tsx
{
	(estado === Estado.Salvando) && <p>Salvando...</p>
}
```

E a mensagem de sucesso do salvamento, no estado ***Salvo***:

```tsx
{
	(estado === Estado.Salvo) && <p>SUCESSO em salvar!</p>
}
```

Assim como a mensagem de falha, no estado ***Erro Salvar***:

```tsx
{
	(estado === Estado.ErroSalvar) && <p>ERRO ao tentar salvar.</p>
}
```

ğŸ“„ Nesse ponto, o cÃ³digo completo do script ***/src/pages/item.tsx*** fica entÃ£o assim:

```tsx
import { FunctionComponent, useEffect, useState } from 'react'
import { useParams } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Editando,
		Salvando,
		ErroSalvar,
		Salvo,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [item, setItem] = useState<Item>()

	useEffect(() => {
		if (id) {
			itensService.ler(
				+id,
				item => {
					setItem(item)
					setEstado(Estado.Lido)
				},
				() => setEstado(Estado.ErroLer)
			)
		}
	}, [id, Estado.Lido, Estado.ErroLer])

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.Salvo) && <p>SUCESSO em salvar!</p>
			}

			{
				(estado === Estado.ErroSalvar) && <p>ERRO ao tentar salvar.</p>
			}
				
			{
				((estado === Estado.Lido) || (estado === Estado.Salvo)) &&
				<>
					<h1>{item?.nome}</h1>
					<p>{item?.descricao}</p>
					<div>
						<button>Editar</button>
					</div>
				</>
			}

			{
				((estado === Estado.Editando) || (estado === Estado.ErroSalvar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea></textarea>
						</label>
					</div>
					<div>
						<button>Salvar</button>
						<button>Cancelar</button>
					</div>
				</form>
			}
		</>
	)
}

export default ItemPage
```

### EdiÃ§Ã£o dos dados

Quando o usuÃ¡rio der um clique no botÃ£o ***Editar***, os controles de ediÃ§Ã£o devem ser exibidos juntamente com os botÃµes de ***Salvar*** e ***Cancelar***. 

Depois que digitar os novos valores, existe a alternativa do usuÃ¡rio poder cancelar a alteraÃ§Ã£o. Por essa razÃ£o, vamos entÃ£o preservar os dados originais no state **`item`** e criar dois novos *states* para guardar os novos valores do *nome* e da *descriÃ§Ã£o* digitados.

Logo abaixo do *state* **`item`** acrescentamos:

```tsx
const [novoNome, setNovoNome] = useState('')
const [novaDescricao, setNovaDescricao] = useState('')
```

O clique no botÃ£o ***Editar*** deverÃ¡ entÃ£o mudar o estado geral da pÃ¡gina para ***Editando*** e copiar os valores atuais do *Item* para esses dois novos estados.

Assim, logo apÃ³s o **`useEffect()`** vamos adicionar o seguinte cÃ³digo de resposta (*handler*) ao clique no botÃ£o ***Editar***:

```tsx
const handleEditarClick = () => {
	setNovoNome(item!.nome)
	setNovaDescricao(item!.descricao)
	setEstado(Estado.Editando)
}
```

E na marcaÃ§Ã£o do prÃ³prio botÃ£o ***Editar***, vamos adicionar o atributo **`onClick`**:

```tsx
<button onClick={handleEditarClick}>Editar</button>
```

Para completar o recurso de ediÃ§Ã£o, Ã© preciso entÃ£o sincronizar o valor dos controles do formulÃ¡rio com o valor dos *states*.

Assim, logo abaixo do *handler* de clique no botÃ£o ***Editar***, vamos criar dois novos *handlers* como resposta Ã  mudanÃ§a dos valores preenchidos nesses controles do formulÃ¡rio. O cÃ³digo desses *hanlders* irÃ£o atualizar os *states* com o que estÃ¡ sendo digitado pelo usuÃ¡rio:

```tsx
const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNovoNome(event.currentTarget.value)

const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setNovaDescricao(event.currentTarget.value)
```

Lembrando de importar a *interface* **`ChangeEvent`**no inÃ­cio do arquivo:

```
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
```

Vamos tambÃ©m definir esses *handlers* como resposta ao evento de ***Change*** dos controles, adicionando o atributo **`onChange`**, assim como definindo o valor dos controles como sendo o valor nos *states* **`novoNome`** e **`novaDescricao`**:

```tsx
<input value={novoNome} onChange={handleNomeChange} />
```

```tsx
<textarea onChange={handleDescricaoChange} value={novaDescricao} />
```

Para completar, vamos criar tambÃ©m *handlers*, logo abaixo dos anteriores, para responder ao clique nos botÃµes ***Salvar*** e ***Cancelar***, simplesmente, nesse primeiro momento, mudando o *estado* da pÃ¡gina:

```tsx
const handleSalvarClick = () => setEstado(Estado.Salvando)
const handleCancelarClick = () => setEstado(Estado.Lido)
```

Precisamos tambÃ©m definir esses *handlers* como resposta ao evento de ***Click*** dos respectivos botÃµes:

```tsx
<button onClick={handleSalvarClick}>Salvar</button>
<button onClick={handleCancelarClick}>Cancelar</button>
```

Nesse ponto vocÃª pode testar essa tela no navegador, dando clique no botÃ£o ***Editar*** e ***Cancelar***.

### Salvar os dados

Vamos agora adicionar a operaÃ§Ã£o de atualizar os dados de um *Item* especÃ­fico a partir do servidor.

Assim, vamos adicionar no arquivo ***/src/services/itens.ts***, logo abaixo da funÃ§Ã£o **`ler`**, o cÃ³digo para efetuar essa nova operaÃ§Ã£o:

```tsx
atualizar: (item: Item, sucesso: () => void, falha: () => void) => {
	axios.put(`http://localhost:4000/api/itens/${item.id}`, item)
	.then(res => (res.status === 204) ? sucesso() : falha())
	.catch(error => falha())
},
```

ğŸ“„ O cÃ³digo completo desse script fica assim:

```tsx
import axios from 'axios'
import Item from '../models/item'

const itensService = {

	lerTodos: (sucesso: (itens: Item[]) => void, falha: () => void) => {
		axios.get<Item[]>('http://localhost:4000/api/itens')
		.then(res => sucesso(res.data))
		.catch(() => falha())
	},

	ler: (id: number, sucesso: (item: Item) => void, falha: () => void) => {
		axios.get<Item>(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 200) ? sucesso(res.data) : falha())
		.catch(error => falha())
	},

	atualizar: (item: Item, sucesso: () => void, falha: () => void) => {
		axios.put(`http://localhost:4000/api/itens/${item.id}`, item)
		.then(res => (res.status === 204) ? sucesso() : falha())
		.catch(error => falha())
	},

}

export default itensService
```

Feito isso, vamos entÃ£o substituir o cÃ³digo do *handler* de resposta ao clique no botÃ£o ***Salvar***, no script da pÃ¡gina ***Item***, para chamar essa operaÃ§Ã£o:

```tsx
const handleSalvarClick = () => {

	setEstado(Estado.Salvando)

	if (id) {
		const novoItem = {
			id: +id,
			nome: novoNome,
			descricao: novaDescricao
		}
	
		itensService.atualizar(
			novoItem,
			() => {
				setItem(novoItem)
				setEstado(Estado.Salvo)
			},
			() => setEstado(Estado.ErroSalvar)
		)
	} else {
		setEstado(Estado.ErroSalvar)
	}
	
}
```

ğŸ“„ O cÃ³digo completo desse script fica entÃ£o:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
import { useParams } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Editando,
		Salvando,
		ErroSalvar,
		Salvo,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [item, setItem] = useState<Item>()
	const [novoNome, setNovoNome] = useState('')
	const [novaDescricao, setNovaDescricao] = useState('')

	useEffect(() => {
		if (id) {
			itensService.ler(
				+id,
				item => {
					setItem(item)
					setEstado(Estado.Lido)
				},
				() => setEstado(Estado.ErroLer)
			)
		}
	}, [id, Estado.Lido, Estado.ErroLer])

	const handleEditarClick = () => {
		setNovoNome(item!.nome)
		setNovaDescricao(item!.descricao)
		setEstado(Estado.Editando)
	}

	const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNovoNome(event.currentTarget.value)

	const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setNovaDescricao(event.currentTarget.value)

	const handleSalvarClick = () => {

		setEstado(Estado.Salvando)
	
		if (id) {
			const novoItem = {
				id: +id,
				nome: novoNome,
				descricao: novaDescricao
			}
		
			itensService.atualizar(
				novoItem,
				() => {
					setItem(novoItem)
					setEstado(Estado.Salvo)
				},
				() => setEstado(Estado.ErroSalvar)
			)
		} else {
			setEstado(Estado.ErroSalvar)
		}
		
	}
	
	const handleCancelarClick = () => setEstado(Estado.Lido)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.Salvo) && <p>SUCESSO em salvar!</p>
			}

			{
				(estado === Estado.ErroSalvar) && <p>ERRO ao tentar salvar.</p>
			}
				
			{
				((estado === Estado.Lido) || (estado === Estado.Salvo)) &&
				<>
					<h1>{item?.nome}</h1>
					<p>{item?.descricao}</p>
					<div>
					<button onClick={handleEditarClick}>Editar</button>
					</div>
				</>
			}

			{
				((estado === Estado.Editando) || (estado === Estado.ErroSalvar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input value={novoNome} onChange={handleNomeChange} />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea onChange={handleDescricaoChange} value={novaDescricao} />
						</label>
					</div>
					<div>
						<button onClick={handleSalvarClick}>Salvar</button>
						<button onClick={handleCancelarClick}>Cancelar</button>
					</div>
				</form>
			}
		</>
	)
}

export default ItemPage
```

### Commit â€“ *[+] editar item*

Para esse tutorial, nesse ponto, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um *commit*:

```sh
git add .
git commit -m "[+] editar item"
```

------

## 6. Remover Item

A partir dessa mesma pÃ¡gina ***Item***, o usuÃ¡rio vai poder tambÃ©m remover o *Item* do sistema.

### Estados da pÃ¡gina

Assim, o comportamento dessa pÃ¡gina vai ter, agora, mais 3 novos estados:

- **Removendo:** exibe uma mensagem de progresso enquanto tenta remover o *Item*.
- **Erro Remover:** exibe uma mensagem de erro caso haja falha ao remover o *Item*.
- **Removido:** exibe uma mensagem de sucesso em relaÃ§Ã£o Ã  remoÃ§Ã£o.

 Ou seja, 10 estados no total, como ilustrado na figura seguinte:

![README-front-end-wireframe-fase-3](https://miro.medium.com/max/1400/1*TmALKlAFTKM7VHhNUSfKtg.png)

*Figura 5 â€“ Wireframe e fluxo entre os estados da pÃ¡gina de detalhes do Item.*

### Estados

De acordo com o wireframe definido na *Figura 5* vamos ajustar o cÃ³digo do *enum* **`Estado`**, em ***/src/pages/item.tsx***, acrescentando esses os 3 novos estados que faltam, ficando entÃ£o assim:

```tsx
enum Estado {
	Lendo,
	ErroLer,
	Lido,
	Editando,
	Salvando,
	ErroSalvar,
	Salvo,
	Removendo,
	ErroRemover,
	Removido,
}
```

### Elementos da interface

Como prÃ³ximo passo, vamos completar o HTML da pÃ¡gina, contendo todos os demais elementos que podem ser exibidos em cada um desses estados.

Ou seja, logo abaixo da mensagem de erro ao tentar salvar, vamos adicionar a mensagem de progresso ao se tentar remover o *Item*:

```tsx
{
	(estado === Estado.Removendo) && <p>Removendo...</p>
}
```

E, logo abaixo dessa, vamos adicionar a mensagem de erro ao tentar remover:

```tsx
{
	(estado === Estado.ErroRemover) && <p>ERRO ao tentar remover.</p>
}
```

E, na sequÃªncia, vamos adicionar tambÃ©m a mensagem de sucesso da remoÃ§Ã£o, juntamente com o botÃ£o de ***Voltar***:

```tsx
{
	(estado === Estado.Removido) &&
	<>
		<p>SUCESSO em remover!</p>
		<button>Voltar</button>
	</>
}
```

 Junto ao botÃ£o de ***Editar***, vamos acrescentar um novo botÃ£o, ***Remover***:

```tsx
<button onClick={handleEditarClick}>Editar</button>
<button>Remover</button>
```

ğŸ“„ O cÃ³digo completo dessa pÃ¡gina, atÃ© esse ponto, fica assim entÃ£o:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
import { useParams } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Editando,
		Salvando,
		ErroSalvar,
		Salvo,
		Removendo,
		ErroRemover,
		Removido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [item, setItem] = useState<Item>()
	const [novoNome, setNovoNome] = useState('')
	const [novaDescricao, setNovaDescricao] = useState('')

	useEffect(() => {
		if (id) {
			itensService.ler(
				+id,
				item => {
					setItem(item)
					setEstado(Estado.Lido)
				},
				() => setEstado(Estado.ErroLer)
			)
		}
	}, [id, Estado.Lido, Estado.ErroLer])

	const handleEditarClick = () => {
		setNovoNome(item!.nome)
		setNovaDescricao(item!.descricao)
		setEstado(Estado.Editando)
	}

	const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNovoNome(event.currentTarget.value)

	const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setNovaDescricao(event.currentTarget.value)

	const handleSalvarClick = () => {

		setEstado(Estado.Salvando)
	
		if (id) {
			const novoItem = {
				id: +id,
				nome: novoNome,
				descricao: novaDescricao
			}
		
			itensService.atualizar(
				novoItem,
				() => {
					setItem(novoItem)
					setEstado(Estado.Salvo)
				},
				() => setEstado(Estado.ErroSalvar)
			)
		} else {
			setEstado(Estado.ErroSalvar)
		}
		
	}

	const handleCancelarClick = () => setEstado(Estado.Lido)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.Salvo) && <p>SUCESSO em salvar!</p>
			}

			{
				(estado === Estado.ErroSalvar) && <p>ERRO ao tentar salvar.</p>
			}

			{
				(estado === Estado.Removendo) && <p>Removendo...</p>
			}

			{
				(estado === Estado.ErroRemover) && <p>ERRO ao tentar remover.</p>
			}

			{
				(estado === Estado.Removido) &&
				<>
					<p>SUCESSO em remover!</p>
					<button>Voltar</button>
				</>
			}
				
			{
				((estado === Estado.Lido) || (estado === Estado.Salvo)) &&
				<>
					<h1>{item?.nome}</h1>
					<p>{item?.descricao}</p>
					<div>
						<button onClick={handleEditarClick}>Editar</button>
						<button>Remover</button>
					</div>
				</>
			}

			{
				((estado === Estado.Editando) || (estado === Estado.ErroSalvar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input value={novoNome} onChange={handleNomeChange} />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea onChange={handleDescricaoChange} value={novaDescricao} />
						</label>
					</div>
					<div>
					<button onClick={handleSalvarClick}>Salvar</button>
					<button onClick={handleCancelarClick}>Cancelar</button>
					</div>
				</form>
			}
		</>
	)
}

export default ItemPage
```

### Service

Vamos agora adicionar a operaÃ§Ã£o de remover um *Item* especÃ­fico a partir do servidor.

Assim, vamos ajustar o cÃ³digo do **`itensService`** para efetuar essa a operaÃ§Ã£o, adicionando, logo abaixo da **`atualizar`**, no arquivo ***/src/services/itens.ts***, a seguinte funÃ§Ã£o:

```tsx
remover: (id: string, sucesso: () => void, falha: () => void) => {
	axios.delete(`http://localhost:4000/api/itens/${id}`)
	.then(res => (res.status === 204) ? sucesso() : falha())
	.catch(error => falha())
},
```

Como nas outras funÃ§Ãµes desse objeto, essa utiliza o Axios para fazer uma chamada HTTP com mÃ©todo *DELETE* no servidor, realizando assim a operaÃ§Ã£o de remoÃ§Ã£o de um *Item* no sistema.

O arquivo completo fica entÃ£o:

```tsx
import axios from 'axios'
import Item from '../models/item'

const itensService = {

	lerTodos: (sucesso: (itens: Item[]) => void, falha: () => void) => {
		axios.get<Item[]>('http://localhost:4000/api/itens')
		.then(res => sucesso(res.data))
		.catch(() => falha())
	},

	ler: (id: number, sucesso: (item: Item) => void, falha: () => void) => {
		axios.get<Item>(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 200) ? sucesso(res.data) : falha())
		.catch(error => falha())
	},

	atualizar: (item: Item, sucesso: () => void, falha: () => void) => {
		axios.put(`http://localhost:4000/api/itens/${item.id}`, item)
		.then(res => (res.status === 204) ? sucesso() : falha())
		.catch(error => falha())
	},

	remover: (id: string, sucesso: () => void, falha: () => void) => {
		axios.delete(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 204) ? sucesso() : falha())
		.catch(error => falha())
	},

}

export default itensService
```

### BotÃ£o Remover

Voltando Ã  pÃ¡gina ***Item***, o clique no botÃ£o ***Remover*** deverÃ¡ mudar o estado geral dessa pÃ¡gina para ***Removendo***  e acionar a operaÃ§Ã£o no servidor. Assim, logo antes do *return* da pÃ¡gina, acrescentamos o cÃ³digo desse novo *handler*:

```tsx
const handleRemoverClick = () => {
	setEstado(Estado.Removendo)
	if (id) {
		itensService.remover(
		id,
		() => setEstado(Estado.Removido),
		() => setEstado(Estado.ErroRemover)
		)
	} else {
		setEstado(Estado.ErroRemover)
	}
}
```

E na marcaÃ§Ã£o do botÃ£o ***Remover***, acrecentamos o atributo **`onClick`**:

```tsx
<button onClick={handleRemoverClick}>Remover</button>
```

### BotÃ£o Voltar

ApÃ³s removido, o botÃ£o ***Voltar*** Ã© exibido â€” um clique nesse botÃ£o deverÃ¡ levar de volta para a tela ***Itens***.

Assim vamos acrecentar, logo apÃ³s o **`handleRemoverClick`**:

```tsx
const navigate = useNavigate()
const handleVoltarClick = () => navigate('/itens')
```

E na marcaÃ§Ã£o do botÃ£o:

```tsx
<button onClick={handleVoltarClick}>Voltar</button>
```

Lembrando de importar a funÃ§Ã£o **`useNavigate`**:

```tsx
import { useNavigate, useParams } from 'react-router-dom'
```

ğŸ“„ O cÃ³digo completo da pÃ¡gina fica entÃ£o:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
import { useNavigate, useParams } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItemPage: FunctionComponent = () => {
	const { id } = useParams()

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Editando,
		Salvando,
		ErroSalvar,
		Salvo,
		Removendo,
		ErroRemover,
		Removido,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [item, setItem] = useState<Item>()
	const [novoNome, setNovoNome] = useState('')
	const [novaDescricao, setNovaDescricao] = useState('')

	useEffect(() => {
		if (id) {
			itensService.ler(
				+id,
				item => {
					setItem(item)
					setEstado(Estado.Lido)
				},
				() => setEstado(Estado.ErroLer)
			)
		}
	}, [id, Estado.Lido, Estado.ErroLer])

	const handleEditarClick = () => {
		setNovoNome(item!.nome)
		setNovaDescricao(item!.descricao)
		setEstado(Estado.Editando)
	}

	const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNovoNome(event.currentTarget.value)

	const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setNovaDescricao(event.currentTarget.value)

	const handleSalvarClick = () => {

		setEstado(Estado.Salvando)
	
		if (id) {
			const novoItem = {
				id: +id,
				nome: novoNome,
				descricao: novaDescricao
			}
		
			itensService.atualizar(
				novoItem,
				() => {
					setItem(novoItem)
					setEstado(Estado.Salvo)
				},
				() => setEstado(Estado.ErroSalvar)
			)
		} else {
			setEstado(Estado.ErroSalvar)
		}
		
	}

	const handleCancelarClick = () => setEstado(Estado.Lido)

	const handleRemoverClick = () => {
		setEstado(Estado.Removendo)
		if (id) {
			itensService.remover(
			id,
			() => setEstado(Estado.Removido),
			() => setEstado(Estado.ErroRemover)
			)
		} else {
			setEstado(Estado.ErroRemover)
		}
	}

	const navigate = useNavigate()
	const handleVoltarClick = () => navigate('/itens')

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}
	
			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.Salvo) && <p>SUCESSO em salvar!</p>
			}

			{
				(estado === Estado.ErroSalvar) && <p>ERRO ao tentar salvar.</p>
			}

			{
				(estado === Estado.Removendo) && <p>Removendo...</p>
			}

			{
				(estado === Estado.ErroRemover) && <p>ERRO ao tentar remover.</p>
			}

			{
				(estado === Estado.Removido) &&
				<>
					<p>SUCESSO em remover!</p>
					<button onClick={handleVoltarClick}>Voltar</button>
				</>
			}
				
			{
				((estado === Estado.Lido) || (estado === Estado.Salvo)) &&
				<>
					<h1>{item?.nome}</h1>
					<p>{item?.descricao}</p>
					<div>
						<button onClick={handleEditarClick}>Editar</button>
						<button onClick={handleRemoverClick}>Remover</button>
					</div>
				</>
			}

			{
				((estado === Estado.Editando) || (estado === Estado.ErroSalvar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input value={novoNome} onChange={handleNomeChange} />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea onChange={handleDescricaoChange} value={novaDescricao} />
						</label>
					</div>
					<div>
					<button onClick={handleSalvarClick}>Salvar</button>
					<button onClick={handleCancelarClick}>Cancelar</button>
					</div>
				</form>
			}
		</>
	)
}

export default ItemPage
```

### Commit â€“ *[+] remover item*

Para esse tutorial, nesse ponto, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um *commit*:

```sh
git add .
git commit -m "[+] remover item"
```

## 7. Criar Item

Para finalizar o conjunto de operaÃ§Ãµes bÃ¡sicas, faltou a operaÃ§Ã£o de criar um novo *Item* no sistema.

Vamos entÃ£o voltar lÃ¡ no arquivo da pÃ¡gina ***Itens***, ***/src/pages/itens.tsx***, e ajustar o cÃ³digo, acrescentando mais 4 estados:

- **Criar:** exibe o formulÃ¡rio para entrar com os dados do novo *Item*.
- **Salvando:** exibe uma mensagem de progresso enquanto efetua essa operaÃ§Ã£o no servidor.
- **Erro Criar:** exibe uma mensagem de erro caso haja falha na operaÃ§Ã£o.
- **Criado:** exibe uma mensagem de sucesso.

A figura seguinte ilustra o fluxo completo entre os estados dessa pÃ¡gina:

![README-front-end-itens-fase-2](https://miro.medium.com/max/1400/1*4dIvPbcxbsu7Vxh-ngZ2Ig.png)

*Figura 6 â€“ Wireframe e fluxo completo entre os estados da pÃ¡gina de lista de Itens.*

### Estados

De acordo com o wireframe definido na *Figura 6*, o cÃ³digo do enum **`Estado`** fica entÃ£o assim:

```tsx
enum Estado {
	Lendo,
	ErroLer,
	Lido,
	Criar,
	Salvando,
	ErroCriar,
	Criado,
}
```

### Elementos da interface

Como prÃ³ximo passo, vamos completar o HTML da pÃ¡gina, adicionando todos os demais elementos que podem ser exibidos em cada um desses estados.

Ou seja, logo abaixo do bloco do estado ***Lido***, vamos adicionar a mensagem de sucesso ao criar o novo *Item* e o botÃ£o ***Novo***:

```tsx
{
	(estado === Estado.Criado) && <p>SUCESSO em criar.</p>
}

{
  ((estado === Estado.Lido) || (estado === Estado.Criado)) && <button>Novo</button>
}
```

E logo abaixo, vamos adicionar o cÃ³digo do formulÃ¡rio de cadastro:

```tsx
{
	((estado === Estado.Criar) || (estado === Estado.ErroCriar)) &&
	<form>
		<div>
			<label>
				Nome:
				<input />
			</label>
		</div>
		<div>
			<label>
				DescriÃ§Ã£o:
				<textarea />
			</label>
		</div>
		<div>
			<button>Salvar</button>
			<button>Cancelar</button>
		</div>
	</form>
}
```

E logo abaixo, vamos adicionar a mensagem de progresso da execuÃ§Ã£o da operaÃ§Ã£o de salvar o novo *Item*:

```tsx
{
	(estado === Estado.Salvando) && <p>Salvando...</p>
}
```

E, na sequÃªncia, adicionar a mensagem de erro ao tentar salvar:

```tsx
{
	(estado === Estado.ErroCriar) && <p>ERRO ao tentar criar.</p>
}
```

Vamos tambÃ©m ajustar o bloco da lista de Itens, que deverÃ¡ ser mostrado tambÃ©m nos estados ***Criar*** e ***Criado***:

```tsx
{
	((estado === Estado.Lido) || (estado === Estado.Criar) || (estado === Estado.Criado)) &&
	<>
		<h1>Itens</h1>
		<ul>
		{
			itens.map(item => <li key={item.id}><Link to={`/itens/${item.id}`}>{item.nome}</Link></li>)
		}
		</ul>
	</>
}
```

### CriaÃ§Ã£o de um novo Item

Para guardar os valores dos campos *nome* e *descriÃ§Ã£o*, digitados pelo usuÃ¡rio, para o novo *Item* a ser criado, vamos entÃ£o criar dois novos *states*, logo abaixo do *state* **`itens`**:

```tsx
const [nome, setNome] = useState('')
const [descricao, setDescricao] = useState('')
```

Quando o usuÃ¡rio der um clique no botÃ£o ***Novo***, o formulÃ¡rio deve ser exibido juntamente com os botÃµes de ***Salvar*** e ***Cancelar***.

Assim, logo apÃ³s o bloco do **`useEffect`**,  vamos adicionar o seguinte cÃ³digo de resposta (*handler*) ao clique no botÃ£o ***Novo***:

```tsx
const handleNovoClick = () => {
  setNome('')
  setDescricao('')
  setEstado(Estado.Criar)
}
```

E na marcaÃ§Ã£o do prÃ³prio botÃ£o ***Novo***, vamos adicionar o atributo **`onClick`**:

```tsx
<button onClick={handleNovoClick}>Novo</button>
```

Vamos fazer o mesmo para o botÃ£o ***Cancelar***, ou seja adicionar o *handler* de resposta ao clique nesse botÃ£o, logo apÃ³s o *handler* do botÃ£o ***Novo***:

```tsx
const handleCancelarClick = () => setEstado(Estado.Lido)
```

E adicionar o atributo **`onClick`** na marcaÃ§Ã£o do botÃ£o:

```tsx
<button onClick={handleCancelarClick}>Cancelar</button>
```

E o mesmo, tambÃ©m, para o botÃ£o ***Salvar***:

```tsx
const handleSalvarClick = () => setEstado(Estado.Salvando)
```

```tsx
<button onClick={handleSalvarClick}>Salvar</button>
```

Para completar o recurso de criaÃ§Ã£o, Ã© preciso entÃ£o sincronizar o valor dos controles do formulÃ¡rio com o valor dos *states*.

Assim, logo abaixo do *handler* de clique no botÃ£o ***Salvar***, vamos criar dois novos *handlers* como resposta Ã  mudanÃ§a dos valores preenchidos nesses controles do formulÃ¡rio. O cÃ³digo desses *handlers* irÃ£o atualizar os *states* com o que estÃ¡ sendo digitado pelo usuÃ¡rio:

```tsx
const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNome(event.currentTarget.value)

const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setDescricao(event.currentTarget.value)
```

NÃ£o esquecendo de importar a *interface* **`ChangeEvent`**, no inÃ­cio do arquivo:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
```

Vamos tambÃ©m definir esses *handlers* como resposta ao evento de ***Change*** dos controles, adicionando o atributo **`onChange`**, assim como definindo o valor dos controles como sendo dos *states* **`nome`** e **`descricao`**:

```tsx
<input value={nome} onChange={handleNomeChange} />
```

```tsx
<textarea onChange={handleDescricaoChange} value={descricao} />
```



ğŸ“„ Nesse ponto, o cÃ³digo completo da pÃ¡gina fica assim entÃ£o:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
import { Link } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItensPage: FunctionComponent = () => {

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Criar,
		Salvando,
		ErroCriar,
		Criado,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [itens, setItens] = useState<Item[]>([])
	const [nome, setNome] = useState('')
	const [descricao, setDescricao] = useState('')

	useEffect(() => {
		setEstado(Estado.Lendo)
		itensService.lerTodos(
			itens => {
				setItens(itens)
				setEstado(Estado.Lido)
			},
			() => setEstado(Estado.ErroLer)
		)
	}, [Estado.ErroLer, Estado.Lendo, Estado.Lido])

	const handleNovoClick = () => {
		setNome('')
		setDescricao('')
		setEstado(Estado.Criar)
	}

	const handleCancelarClick = () => setEstado(Estado.Lido)
	const handleSalvarClick = () => setEstado(Estado.Salvando)

	const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNome(event.currentTarget.value)

	const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setDescricao(event.currentTarget.value)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}

			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				((estado === Estado.Lido) || (estado === Estado.Criar) || (estado === Estado.Criado)) &&
				<>
					<h1>Itens</h1>
					<ul>
					{
						itens.map(item => <li key={item.id}><Link to={`/itens/${item.id}`}>{item.nome}</Link></li>)
					}
					</ul>
				</>
			}

			{
				(estado === Estado.Criado) && <p>SUCESSO em criar.</p>
			}

			{
				((estado === Estado.Lido) || (estado === Estado.Criado)) &&
				<button onClick={handleNovoClick}>Novo</button>
			}

			{
				((estado === Estado.Criar) || (estado === Estado.ErroCriar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input value={nome} onChange={handleNomeChange} />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea onChange={handleDescricaoChange} value={descricao} />
						</label>
					</div>
					<div>
					<button onClick={handleSalvarClick}>Salvar</button>
						<button onClick={handleCancelarClick}>Cancelar</button>
					</div>
				</form>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.ErroCriar) && <p>ERRO ao tentar criar.</p>
			}
		</>
	)
}

export default ItensPage
```

### Service

Vamos agora adicionar a operaÃ§Ã£o de criar um novo *Item* no servidor.

Assim, vamos ajustar o cÃ³digo do **`itensService`** para efetuar essa a operaÃ§Ã£o, adicionando, logo abaixo da **`remover`**, no arquivo ***/src/services/itens.ts***, a seguinte funÃ§Ã£o:

```tsx
criar: (item: Item, sucesso: (item: Item) => void, falha: () => void) => {
	axios.post(`http://localhost:4000/api/itens`, item)
	.then(res => {
		if (res.status === 201) {
			const itemUrl = `http://localhost:4000/api${res.headers.location}`
			axios.get<Item>(itemUrl)
				.then(res => (res.status === 200) ? sucesso(res.data) : falha())
				.catch(error => falha())
		} else {
			falha()
		}
	})
	.catch(error => falha())
},
```

ğŸ“„ O arquivo completo fica entÃ£o:

```tsx
import axios from 'axios'
import Item from '../models/item'

const itensService = {

	lerTodos: (sucesso: (itens: Item[]) => void, falha: () => void) => {
		axios.get<Item[]>('http://localhost:4000/api/itens')
		.then(res => sucesso(res.data))
		.catch(() => falha())
	},

	ler: (id: number, sucesso: (item: Item) => void, falha: () => void) => {
		axios.get<Item>(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 200) ? sucesso(res.data) : falha())
		.catch(error => falha())
	},

	atualizar: (item: Item, sucesso: () => void, falha: () => void) => {
		axios.put(`http://localhost:4000/api/itens/${item.id}`, item)
		.then(res => (res.status === 204) ? sucesso() : falha())
		.catch(error => falha())
	},

	remover: (id: string, sucesso: () => void, falha: () => void) => {
		axios.delete(`http://localhost:4000/api/itens/${id}`)
		.then(res => (res.status === 204) ? sucesso() : falha())
		.catch(error => falha())
	},

	criar: (item: Item, sucesso: (item: Item) => void, falha: () => void) => {
		axios.post(`http://localhost:4000/api/itens`, item)
		.then(res => {
			if (res.status === 201) {
				const itemUrl = `http://localhost:4000/api${res.headers.location}`
				axios.get<Item>(itemUrl)
					.then(res => (res.status === 200) ? sucesso(res.data) : falha())
					.catch(error => falha())
			} else {
				falha()
			}
		})
		.catch(error => falha())
	},

}

export default itensService
```

> #### Explicando o cÃ³digo:
>
> ApÃ³s ser criado, queremos que o novo *Item* seja adicionado na lista de *Itens* da pÃ¡gina.
>
> Por esse motivo, esse novo mÃ©todo **`criar`**, irÃ¡ realizar duas chamadas no servidor: uma para efetuar propriamente a criaÃ§Ã£o do *Item*:
>
> ```tsx
> axios.post(`http://localhost:4000/api/itens`, item)
> ```
>
> e outra para conseguir os dados do *Item* que acabou de ser criado:
>
> ```tsx
> axios.get<Item>(itemUrl)
> ```
>
> A rota usada na segunda chamada Ã© enviada pelo servidor no cabeÃ§alho da primeira chamada:
>
> ```tsx
> const itemUrl = `http://localhost:4000/api${res.headers.location}`
> ```
>
> Ao sucesso da execuÃ§Ã£o dessas duas operaÃ§Ãµes, o mÃ©todo **`criar`** chama a funÃ§Ã£o de *callback*, passando os dados do *Item* (corpo da resposta **`res.data`**) criado como parÃ¢metro:
>
> ```tsx
> sucesso(res.data)
> ```

### BotÃ£o Salvar

Voltando ao script da pÃ¡gina ***Itens***, o clique no botÃ£o ***Salvar*** deverÃ¡ mudar o estado geral dessa pÃ¡gina para ***Salvando***  e acionar a operaÃ§Ã£o no servidor.

Assim, modificamos o cÃ³digo, em ***/src/pages/item.tsx***, do *handler* para incluir a chamada Ã  operaÃ§Ã£o **`criar`** e para adicionar o novo *Item* criado na lista de *Itens* da pÃ¡gina:

```tsx
const handleSalvarClick = () => {
	setEstado(Estado.Salvando)
	itensService.criar({
			nome: nome,
			descricao: descricao
		},
		item => {
			itens.push(item)
			setEstado(Estado.Criado)
		},
		() => setEstado(Estado.ErroCriar)
	)
}
```

ğŸ“„ O cÃ³digo completo da pÃ¡gina fica entÃ£o:

```tsx
import { ChangeEvent, FunctionComponent, useEffect, useState } from 'react'
import { Link } from 'react-router-dom'
import Item from '../models/item'
import itensService from '../services/itens'

const ItensPage: FunctionComponent = () => {

	enum Estado {
		Lendo,
		ErroLer,
		Lido,
		Criar,
		Salvando,
		ErroCriar,
		Criado,
	}

	const [estado, setEstado] = useState(Estado.Lendo)
	const [itens, setItens] = useState<Item[]>([])
	const [nome, setNome] = useState('')
	const [descricao, setDescricao] = useState('')

	useEffect(() => {
		setEstado(Estado.Lendo)
		itensService.lerTodos(
			itens => {
				setItens(itens)
				setEstado(Estado.Lido)
			},
			() => setEstado(Estado.ErroLer)
		)
	}, [Estado.ErroLer, Estado.Lendo, Estado.Lido])

	const handleNovoClick = () => {
		setNome('')
		setDescricao('')
		setEstado(Estado.Criar)
	}

	const handleCancelarClick = () => setEstado(Estado.Lido)
	
	const handleSalvarClick = () => {
		setEstado(Estado.Salvando)
		itensService.criar({
				nome: nome,
				descricao: descricao
			},
			item => {
				itens.push(item)
				setEstado(Estado.Criado)
			},
			() => setEstado(Estado.ErroCriar)
		)
	}

	const handleNomeChange = (event: ChangeEvent<HTMLInputElement>) => setNome(event.currentTarget.value)

	const handleDescricaoChange = (event: ChangeEvent<HTMLTextAreaElement>) => setDescricao(event.currentTarget.value)

	return (
		<>
			{
				(estado === Estado.Lendo) && <p>Carregando...</p>
			}

			{
				(estado === Estado.ErroLer) && <p>ERRO ao tentar carregar.</p>
			}

			{
				((estado === Estado.Lido) || (estado === Estado.Criar) || (estado === Estado.Criado)) &&
				<>
					<h1>Itens</h1>
					<ul>
					{
						itens.map(item => <li key={item.id}><Link to={`/itens/${item.id}`}>{item.nome}</Link></li>)
					}
					</ul>
				</>
			}

			{
				(estado === Estado.Criado) && <p>SUCESSO em criar.</p>
			}

			{
				((estado === Estado.Lido) || (estado === Estado.Criado)) &&
				<button onClick={handleNovoClick}>Novo</button>
			}

			{
				((estado === Estado.Criar) || (estado === Estado.ErroCriar)) &&
				<form>
					<div>
						<label>
							Nome:
							<input value={nome} onChange={handleNomeChange} />
						</label>
					</div>
					<div>
						<label>
							DescriÃ§Ã£o:
							<textarea onChange={handleDescricaoChange} value={descricao} />
						</label>
					</div>
					<div>
					<button onClick={handleSalvarClick}>Salvar</button>
						<button onClick={handleCancelarClick}>Cancelar</button>
					</div>
				</form>
			}

			{
				(estado === Estado.Salvando) && <p>Salvando...</p>
			}

			{
				(estado === Estado.ErroCriar) && <p>ERRO ao tentar criar.</p>
			}
		</>
	)
}

export default ItensPage
```

E aqui chegamos ao fim do nosso aplicativo React desse tutorial.

### Commit â€“ *[+] criar item*

Nesse ponto, vamos registrar essa mudanÃ§a de configuraÃ§Ã£o no projeto, com um *commit*:

```sh
git add .
git commit -m "[+] criar item"
```

Caso queria adicionar esse projeto no GitHub ou BitBucket, crie um novo repositÃ³rio em um desses servidores e, em seguida, execute os seguinte comandos:

```
git remote add origin {url}
git branch -M main
git push -u origin main
```

Substituindo ***{url}*** pela URL do repositÃ³rio criado no servidor.

> VocÃª pode encontrar o cÃ³digo completo desse projeto na minha conta do GitHub, em: https://github.com/eldes/tutorial-rest-api--front-end--react-axios-typescript

------

## ConclusÃ£o

Nesse ponto temos o projeto completo de um *web app* React, que implementa uma interface para as operaÃ§Ãµes bÃ¡sicas do *CRUD* executadas no servidor via uma REST API.

Lembre que vocÃª pode melhorar esse cÃ³digo fazendo *refactoring* e seguindo os conceitos de *Clean Code* e *SOLID*.

------

## ContribuiÃ§Ã£o

ComentÃ¡rios e dÃºvidas sÃ£o bem-vindas, tanto aqui quanto no [Medium](https://medium.com/@eldes.com/tutorial-conexÃ£o-de-um-aplicativo-react-em-typescript-a-um-servidor-rest-api-usando-axios-1eeadc3ad238).
